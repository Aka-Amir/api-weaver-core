import { ApiWeaverClass } from "../core/openapi-class";
import {
  ArraySchemaType,
  EnumSchemaType,
  ObjectSchemaType,
  SchemaPropertyType,
  SchemaRefType,
  SchemaType,
} from "./types/schema.type";
import { FileWriter } from "../core/utils/file-writer/file-writer";
import { FileNameAdapter } from "./utils/convertToImport";
import { EnumBuilder } from "./enum.builder";
import { join } from "path";
import { NonInterfaceException } from "./exceptions/non-interface.exception";

export class Schema extends ApiWeaverClass {
  constructor(
    private title: string,
    private schema: SchemaPropertyType,
    private root: Record<string, ObjectSchemaType>
  ) {
    super();
  }

  private imports: string[] = [];

  private get interfaceName() {
    return Schema.getInterfaceNameFromTitle(this.title);
  }

  static getInterfaceNameFromTitle(title: string) {
    return !title ? "" : `I${title}`;
  }

  // static getEnumPath(title: string) {}

  public get name() {
    switch (this.schema.type) {
      case "object":
        return this.interfaceName;
      case "array":
        return this.title;
      default:
        return "";
    }
  }

  async write() {
    await this.preparePath();
    try {
      await FileWriter.writeCode(
        this.generatePath,
        await this.generateInterface()
      );
      return `export type { ${this.interfaceName} } from "${this.generatePath}"`;
    } catch (e) {
      if (e instanceof NonInterfaceException) return e.entityPath;
      throw e;
    }
  }

  private async generateInterface() {
    let props: string[] = [];
    const prefix = [
      `// This file was generated by OpenApi3 Generator`,
      `export interface ${this.interfaceName} {`,
    ];

    const postfix = ["}", ""];

    switch (this.schema.type) {
      case "object":
        props = await this.processAsObject(this.schema as ObjectSchemaType);
        break;
      case "array":
        prefix[1] = `export type ${this.title} = `;
        postfix[0] = ";";
        props = await this.processAsList(this.schema as ArraySchemaType);
        break;
      case "number":
      case "string":
        if (this.schema.enum) {
          const path = await this.processAsEnum(this.schema);
          throw new NonInterfaceException(path);
        }
        break;
      default:
        break;
    }

    return [
      ...Array.from(new Set(this.imports.map((i) => i.replaceAll("//", "/")))),
      "\n",
      ...prefix,
      ...props,
      ...postfix,
    ].join("\n");
  }

  private async processAsObject(schema: ObjectSchemaType) {
    const properties: string[] = [];
    for (const [key, value] of Object.entries(schema.properties || {})) {
      const type = await this.parseSchemaType(value);
      if (schema.required?.includes(key)) properties.push(`\t${key}: ${type};`);
      else properties.push(`\t${key}?: ${type};`);
    }
    return properties;
  }

  private async processAsList(schema: ArraySchemaType) {
    const type = await this.parseSchemaType(schema);
    return [`${this.title}: ${type}[];`];
  }

  private async processAsEnum(schema: EnumSchemaType) {
    if (!schema.enum) throw new Error("Invalid enum type");
    const [, path] = await this.processEnum(
      this.title,
      new EnumBuilder(schema.enum)
    );
    return path;
  }

  private async parseSchemaType(property: SchemaType) {
    if ("$ref" in property) {
      return this.parseRefType(property);
    }
    return this.translateProperty(property);
  }

  private parseRefType(property: SchemaRefType) {
    const refName = property.$ref.split("/").pop() ?? "";
    const propertySchema = this.root[refName] as SchemaPropertyType;
    let type = "unknown";
    if (!propertySchema) return type;
    if (propertySchema.type === "string" && propertySchema.enum) {
      type = refName;
      this.imports.push(
        `import { ${type} } from "${FileNameAdapter.convertRefToImport(
          property.$ref,
          "enums"
        )}"`
      );
    } else {
      type = Schema.getInterfaceNameFromTitle(refName) || type;
      this.imports.push(
        `import type { ${type} } from "${FileNameAdapter.convertRefToImport(
          property.$ref
        )}"`
      );
    }

    return type;
  }

  private async processEnum(name: string, enumBuilder: EnumBuilder) {
    enumBuilder.setName(name);
    enumBuilder.setGeneratePath(join(this.getParentPath(), "enums"));
    const result = await enumBuilder.build();
    const path = result.path.replace(this.getParentPath(), "..");
    this.imports.push(`import { ${result.moduleName} } from "${path}"`);
    return [result.moduleName, result.path];
  }

  private async translateProperty(
    property: SchemaPropertyType
  ): Promise<string> {
    let moduleName: string;
    switch (property.type) {
      case "array":
        return this.parseArray(property as ArraySchemaType);
      case "object":
        return this.parseObject(property as ObjectSchemaType);
      case "string":
        if (!property.enum) return property.type;
        [moduleName] = await this.processEnum(
          property.title ?? this.getGeneratedName(),
          new EnumBuilder(property.enum)
        );
        return moduleName;
      default:
        return property.type;
    }
  }

  private getGeneratedName() {
    return "GE_" + Date.now().toString(16);
  }

  private async parseObject(property: ObjectSchemaType) {
    const keys = ["{"];
    for (const [key, value] of Object.entries(property.properties || {})) {
      const type = await this.parseSchemaType(value);
      if (property.required?.includes(key)) {
        keys.push(`\t${key}: ${type}`);
      } else {
        keys.push(`\t${key}?: ${type}`);
      }
    }
    return keys.join("\n") + "}";
  }

  private async parseArray(property: ArraySchemaType) {
    const type = await this.parseSchemaType(property.items);
    return `${type}[]`;
  }
}
